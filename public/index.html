<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <style>
        .tk-fill {
            fill: #303030;
        }

        .tk-inboundary {
            fill: none;
            stroke: #505050;
            stroke-width: 1.5;
            stroke-dasharray: 2, 2;
            stroke-linejoin: round;
        }

        .tk-outboundary {
            fill: none;
            stroke: #808080;
            stroke-width: 1;
            stroke-linejoin: round;
        }

        body {
            background: #202020;
        }

        .station {
            fill: #4986bc;
        }

        #pos {
            fill: #3aff3a;
        }
    </style>
</head>
<body>

<div id="map" style="position: absolute;">
    <svg id="map-svg"></svg>
</div>
<div id="mask" style="position: absolute; visibility: hidden;">
    <svg id="mask-svg" style="position: absolute;"></svg>
    <canvas id="mask-canvas" style="position: absolute;"></canvas>
</div>
<div id="field" style="position: absolute; z-index: 10;">
    <canvas id="field-canvas" style="position: absolute;"></canvas>
</div>

<script src="topojson.v1.js"></script>
<script src="d3.v3.js"></script>
<script src="canvg.js"></script>
<script>

    var width = 1200, height = 700;
//    var width = 600, height = 350;
    var π = Math.PI;

    var projection = d3.geo.albers()
        .rotate([-139.3, 0])
        .center([0, 144.20])
        .scale(80000);
//    var projection = d3.geo.albers()
//        .rotate([-139.75, 0])
//        .center([0, 144.40])
//        .scale(40000);

    var path = d3.geo.path().projection(projection);

    var mapSvg = d3.select("#map-svg").attr("width", width).attr("height", height);
    var maskSvg = d3.select("#mask-svg").attr("width", width).attr("height", height);
    var maskCanvas = d3.select("#mask-canvas").attr("width", width).attr("height", height)[0][0];
    var fieldCanvas = d3.select("#field-canvas").attr("width", width).attr("height", height)[0][0];

    d3.json("tk.topojson", function (error, tk) {
        var datum = topojson.feature(tk, tk.objects.tk);

        mapSvg.selectAll(".tk")
            .data(datum.features)
            .enter().append("path")
            .attr("class", "tk-fill")
            .attr("d", path);

        mapSvg.append("path")
            .datum(topojson.mesh(tk, tk.objects.tk, function (a, b) { return a !== b; }))
            .attr("class", "tk-inboundary")
            .attr("d", path);

        mapSvg.append("path")
            .datum(topojson.mesh(tk, tk.objects.tk, function(a, b) { return a === b; }))
            .attr("class", "tk-outboundary")
            .attr("d", path);

        maskSvg.append("path")
            .datum(topojson.mesh(tk, tk.objects.tk, function(a, b) { return a === b; }))
            .attr("fill", "#fff")
            .attr("stroke-width", "50")
            .attr("stroke", "#fff")
            .attr("stroke-linejoin", "round")
            .attr("d", path);

        canvg(maskCanvas, document.getElementById("mask").innerHTML.trim());
        var maskCanvasContext = maskCanvas.getContext("2d");
        var maskData = maskCanvasContext.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;

        for (var x = maskCanvas.width - 1; x >= 0; x -= 1) {
            var column = fieldMask[x] = [];
            for (var y = maskCanvas.height - 1; y >= 0; y -= 1) {
                var i = (y * maskCanvas.width + x) * 4;
                column[y] = maskData[i] > 0;
            }
        }

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                    var p = projection([position.coords.longitude, position.coords.latitude]);
                    var x = Math.round(p[0]);
                    var y = Math.round(p[1]);
                    if (0 <= x && x < width && 0 <= y && y < height) {
                        mapSvg.append("circle")
                            .attr("cx", x)
                            .attr("cy", y)
                            .attr("r", 3)
                            .attr("id", "pos");
                    }
                },
                console.error.bind(console),
                {enableHighAccuracy: true});
        }

        d3.json("stations/geo", function(error, stations) {
            path.pointRadius(1);
            mapSvg.append("path")
                .datum(stations)
                .attr("class", "station")
                .attr("d", path);

            interpolateVectorField();
//            interpolateScalarField('no2');
        });
    });

    var done = false;

    var fieldMask = [];

    d3.select("#field-canvas").on("click", printCoord);

    function printCoord() {
        console.log(d3.mouse(this));
        console.log(projection.invert(d3.mouse(this)));
        done = true;
    }

    var particles = [];
    var maxAge = 150;

    function distance(x1, y1, x2, y2) {
        var xd = Math.abs(x1 - x2);
        var yd = Math.abs(y1 - y2);
        return Math.sqrt(xd * xd + yd * yd);
    }

    function weight(x1, y1, x2, y2) {
        var d = distance(x1, y1, x2, y2);
        return 1 / (d * d);
    }

    function multiply(x, y) {
        return x * y;
    }

    function add(x, y) {
        return x + y;
    }

    function vectorScale(v, m) {
        return [v[0], v[1] * m];
    }

    function vectorAdd(a, b) {
        var ax = Math.cos(a[0]) * a[1];
        var ay = Math.sin(a[0]) * a[1];
        var bx = Math.cos(b[0]) * b[1];
        var by = Math.sin(b[0]) * b[1];

        var cx = ax + bx;
        var cy = ay + by;

        var r = Math.atan2(cy, cx);
        var m = Math.sqrt(cx * cx + cy * cy);

        if (!isFinite(r)) {
            r = 0;
        }
        return [r, m];
    }

    function f(x, y, initial, data, scale, add) {
        var n = initial;
        var d = 0;
        for (var i = 0; i < data.length; i++) {
            var sample = data[i];
            var value = sample[2];
            var w = weight(x, y, sample[0], sample[1]);
            if (w === Number.POSITIVE_INFINITY) {
                return value;
            }
            var s = scale(value, w);
            n = add(n, s);
            d += w;
        }
        return scale(n, 1 / d);
    }

    var c = fieldCanvas;
    var g = c.getContext('2d');

    function interpolateScalarField(sampleType) {
//        d3.json("samples/2013/8/23/11", function(error, samples) {
        d3.json("samples/current", function(error, samples) {
            var values = [];
            samples.forEach(function(sample) {
                if (sample[sampleType]) {
                    values.push([sample.longitude * 1, sample.latitude * 1, sample[sampleType] * 1]);
                }
            });
            var field = [];
            var min = Number.POSITIVE_INFINITY;
            var max = Number.NEGATIVE_INFINITY;
            for (var x = width; x >= 350; x--) {
                field[x] = [];
                for (var y = height; y >= 150; y--) {
                    var p = projection.invert([x, y]);
                    var v = f(p[0], p[1], 0, values, multiply, add);
                    field[x][y] = v;
                    if (v < min) {
                        min = v;
                    }
                    if (v > max) {
                        max = v;
                    }
                }
            }
            processScalarField(field, min, max);
        });

        function processScalarField(field, min, max) {
            var styles = [];
            for (var i = 0; i < 255; i += 1) {
                styles.push('rgba(' + i + ', ' + i + ', ' + i + ', 0.6)');
            }
            var range = max - min;

            for (var x = 350; x < width; x+=1) {
                for (var y = 150; y < height; y+=1) {
                    if (fieldMask[x][y]) {
                        var v = field[x][y];
                        var style = styles[Math.floor((v-min)/range * (styles.length-1))];
                        g.fillStyle = style;
                        g.fillRect(x, y, 1, 1);
                    }
                }
            }
        }
    }

    function interpolateVectorField() {

        // 2013年8月24日16時
        // 2013年8月22日19時
        // 2013年8月21日22時
        // 2013年8月21日17時
        // 2013年8月21日16時
        // 2013年8月21日15時
        // 2013年8月20日22時
        // 2013年8月20日21時 -- and each preceding hour...
        // 2013年8月19日16時
        // 2013年8月18日17時

//        d3.json("samples/2013/8/24/16", function(error, samples) {
//        d3.json("samples/2013/8/22/19", function(error, samples) {
//        d3.json("samples/2013/8/21/22", function(error, samples) {
//        d3.json("samples/2013/8/21/16", function(error, samples) {
//        d3.json("samples/2013/8/21/15", function(error, samples) {
//        d3.json("samples/2013/8/20/22", function(error, samples) {
//        d3.json("samples/2013/8/20/21", function(error, samples) {
//        d3.json("samples/2013/8/20/20", function(error, samples) {
//        d3.json("samples/2013/8/20/19", function(error, samples) {
//        d3.json("samples/2013/8/20/18", function(error, samples) {
//        d3.json("samples/2013/8/19/16", function(error, samples) {
//        d3.json("samples/2013/8/18/17", function(error, samples) {
//        d3.json("samples/2013/8/17/17", function(error, samples) {
        d3.json("samples/2013/8/16/15", function(error, samples) {
//        d3.json("samples/2013/8/12/19", function(error, samples) {
//        d3.json("samples/current", function(error, samples) {
            // Convert cardinal (north origin, clockwise) to radians (counter-clockwise)

            var vectors = [];
            samples.forEach(function(sample) {
                if (sample.wd && sample.wv) {
                    var r = sample.wd / 180 * π;
                    vectors.push([
                        sample.longitude * 1,
                        sample.latitude * 1,
                        [Math.atan2(Math.cos(r), Math.sin(r)), sample.wv * 1]]);
                }
            });

            var field = [];
            for (var x = width-1; x >= 0; x--) {
                var column = field[x] = [];
                for (var y = height-1; y >= 0; y--) {
                    if (fieldMask[x][y]) {
                        var p = projection.invert([x, y]);
                        var v = f(p[0], p[1], [0, 0], vectors, vectorScale, vectorAdd);
                        var r = v[0];
                        var m = v[1];
                        column[y] = [Math.cos(r + π) * m, -Math.sin(r + π) * m, m];
                    }
                }
            }
            processVectorField(field);
        });

        function randomPoint() {
            var x;
            var y;
            do {
                x = Math.random() * (width - 1);
                y = Math.random() * (height - 1);
            } while (!fieldMask[Math.round(x)][Math.round(y)]);
            return [x, y];
        }

        function processVectorField(field) {
            for (var i = 0; i < 5000; i++) {
                var p = randomPoint();
                particles.push({
                    x: p[0],
                    y: p[1],
                    age: Math.floor(Math.random() * maxAge)
                });
            }

            var styles = [];
            for (var j = 150; j < 255; j += 1) {
                styles.push('rgba(' + j + ', ' + j + ', ' + j + ', 1)');
            }
            var max = 17;
            var min = 0;
            var range = max - min;

            draw();

            function draw() {
                var prev = g.globalCompositeOperation;
                g.fillStyle = 'rgba(0, 0, 0, 0.8)';
                g.globalCompositeOperation = "destination-in";
                g.fillRect(0, 0, c.width, c.height);
                g.globalCompositeOperation = prev;

                g.lineWidth = 1;

                g.beginPath();
                particles.forEach(function(particle) {
                    if (particle.age > maxAge) {
                        particle.age = 0;
                        var p = randomPoint();
                        particle.x = p[0];
                        particle.y = p[1];
                    }

                    // get vector at current location
                    var x = particle.x;
                    var y = particle.y;
                    var fx = Math.round(x);
                    var fy = Math.round(y);

                    if (fx < field.length && field[fx] && fy < field[fx].length && field[fx][fy]) {
                        if (fx < fieldMask.length && fy < fieldMask[fx].length && fieldMask[fx][fy]) {
                            var v = field[fx][fy];
                            var xt = x + v[0] * 0.4;
                            var yt = y + v[1] * 0.4;

                            var style = styles[Math.floor((Math.min(v[2], max) - min) / range * (styles.length - 1))];

//                            g.fillStyle = style;
//                            g.fillRect(Math.round(xt), Math.round(yt), 1, 1);

                            g.strokeStyle = style;
                            g.moveTo(Math.round(x), Math.round(y));
                            g.lineTo(Math.round(xt), Math.round(yt));
                        }
                        particle.x = xt;
                        particle.y = yt;
                    }
                    particle.age += 1;
                });
                g.stroke();

                if (!done) {
                    setTimeout(draw, 40);
                }
            }
        }
    }

</script>

</body>
</html>
